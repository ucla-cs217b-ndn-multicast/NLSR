/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2022,  The University of Memphis,
 *                           Regents of the University of California,
 *                           Arizona Board of Regents.
 *
 * This file is part of NLSR (Named-data Link State Routing).
 * See AUTHORS.md for complete list of NLSR authors and contributors.
 *
 * NLSR is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NLSR is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NLSR, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "lsa/name-lsa.hpp"
#include "lsa/adj-lsa.hpp"
#include "lsa/coordinate-lsa.hpp"
#include "test-common.hpp"
#include "adjacent.hpp"
#include "name-prefix-list.hpp"

#include <ndn-cxx/util/time.hpp>

namespace nlsr {
namespace test {

/*
static void
printBytes(ndn::span<const uint8_t> buf)
{
  std::string hex = ndn::toHex(buf);

  for (size_t i = 0; i < hex.size(); i++) {
    if (i > 0 && i % 30 == 0)
      std::cout << "\n  ";

    std::cout << "0x" << hex[i];
    std::cout << hex[++i];

    if ((i + 1) != hex.size())
      std::cout << ", ";
  }
  std::cout << "\n" << "};" << std::endl;
}

printBytes(block);
*/

BOOST_AUTO_TEST_SUITE(TestLsa)

const uint8_t NAME_LSA1[] = {
  0x89, 0x3b, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0C, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x81, 0x12, 0x07, 0x07, 0x08, 0x05,
  0x6E, 0x61, 0x6D, 0x65, 0x31, 0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x81,
  0x00
};

const uint8_t NAME_LSA_EXTRA_NAME[] = {
  0x89, 0x44, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0C, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x81, 0x1B, 0x07, 0x07, 0x08, 0x05,
  0x6E, 0x61, 0x6D, 0x65, 0x31, 0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x07,
  0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, 0x81, 0x00
};

const uint8_t NAME_LSA_DIFF_SEQ[] = {
  0x89, 0x44, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0E, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x81, 0x1B, 0x07, 0x07, 0x08, 0x05,
  0x6E, 0x61, 0x6D, 0x65, 0x31, 0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x07,
  0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, 0x81, 0x00
};

const uint8_t NAME_LSA_DIFF_TS[] = {
  0x89, 0x44, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0E, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x34, 0x34, 0x81, 0x1B, 0x07, 0x07, 0x08, 0x05,
  0x6E, 0x61, 0x6D, 0x65, 0x31, 0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x07,
  0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, 0x81, 0x00
};

BOOST_AUTO_TEST_CASE(NameLsaBasic)
{
  ndn::Name s1{"name1"};
  ndn::Name s2{"name2"};
  NamePrefixList npl1{s1, s2};

  auto testTimePoint = ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196014943));

  // 3rd argument is seqNo
  NameLsa nlsa1("router1", 12, testTimePoint, npl1);
  NameLsa nlsa2("router2", 12, testTimePoint, npl1);

  BOOST_CHECK_EQUAL(nlsa1.getType(), Lsa::Type::NAME);
  BOOST_CHECK(nlsa1.getExpirationTimePoint() == nlsa2.getExpirationTimePoint());

  auto wire = nlsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(NAME_LSA1, NAME_LSA1 + sizeof(NAME_LSA1),
                                wire.begin(), wire.end());

  nlsa1.addName("name3");
  wire = nlsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(NAME_LSA_EXTRA_NAME,
                                NAME_LSA_EXTRA_NAME + sizeof(NAME_LSA_EXTRA_NAME),
                                wire.begin(), wire.end());

  nlsa1.setSeqNo(14);
  wire = nlsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(NAME_LSA_DIFF_SEQ, NAME_LSA_DIFF_SEQ + sizeof(NAME_LSA_DIFF_SEQ),
                                wire.begin(), wire.end());

  testTimePoint =
    ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196024993));
  nlsa1.setExpirationTimePoint(testTimePoint);
  wire = nlsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(NAME_LSA_DIFF_TS, NAME_LSA_DIFF_TS + sizeof(NAME_LSA_DIFF_TS),
                                wire.begin(), wire.end());
  // Not testing router name as not sure if that will ever change once set
}

const uint8_t ADJ_LSA1[] = {
  0x83, 0x58, 0x80, 0x2D, 0x07, 0x13, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04, 0x73, 0x69,
  0x74, 0x65, 0x08, 0x06, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x82, 0x01, 0x0C, 0x8B, 0x13,
  0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34, 0x3A, 0x31,
  0x33, 0x3A, 0x33, 0x34, 0x84, 0x27, 0x07, 0x16, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04,
  0x73, 0x69, 0x74, 0x65, 0x08, 0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79,
  0x8D, 0x03, 0x3A, 0x2F, 0x2F, 0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t ADJ_LSA_EXTRA_NEIGHBOR[] = {
  0x83, 0x80, 0x80, 0x2D, 0x07, 0x13, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04, 0x73, 0x69,
  0x74, 0x65, 0x08, 0x06, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x82, 0x01, 0x0C, 0x8B, 0x13,
  0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34, 0x3A, 0x31,
  0x33, 0x3A, 0x33, 0x34, 0x84, 0x27, 0x07, 0x16, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04,
  0x73, 0x69, 0x74, 0x65, 0x08, 0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79,
  0x8D, 0x03, 0x3A, 0x2F, 0x2F, 0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x84, 0x26, 0x07, 0x15, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x03, 0x65, 0x64, 0x75, 0x08,
  0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79, 0x8D, 0x03, 0x3A, 0x2F, 0x2F,
  0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t ADJ_LSA_DIFF_SEQ[] = {
  0x83, 0x80, 0x80, 0x2D, 0x07, 0x13, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04, 0x73, 0x69,
  0x74, 0x65, 0x08, 0x06, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x82, 0x01, 0x0E, 0x8B, 0x13,
  0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34, 0x3A, 0x31,
  0x33, 0x3A, 0x33, 0x34, 0x84, 0x27, 0x07, 0x16, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04,
  0x73, 0x69, 0x74, 0x65, 0x08, 0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79,
  0x8D, 0x03, 0x3A, 0x2F, 0x2F, 0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x84, 0x26, 0x07, 0x15, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x03, 0x65, 0x64, 0x75, 0x08,
  0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79, 0x8D, 0x03, 0x3A, 0x2F, 0x2F,
  0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t ADJ_LSA_DIFF_TS[] = {
  0x83, 0x80, 0x80, 0x2D, 0x07, 0x13, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04, 0x73, 0x69,
  0x74, 0x65, 0x08, 0x06, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x82, 0x01, 0x0E, 0x8B, 0x13,
  0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34, 0x3A, 0x31,
  0x33, 0x3A, 0x34, 0x34, 0x84, 0x27, 0x07, 0x16, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x04,
  0x73, 0x69, 0x74, 0x65, 0x08, 0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79,
  0x8D, 0x03, 0x3A, 0x2F, 0x2F, 0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x84, 0x26, 0x07, 0x15, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x03, 0x65, 0x64, 0x75, 0x08,
  0x09, 0x61, 0x64, 0x6A, 0x61, 0x63, 0x65, 0x6E, 0x63, 0x79, 0x8D, 0x03, 0x3A, 0x2F, 0x2F,
  0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

BOOST_AUTO_TEST_CASE(AdjLsaBasic)
{
  ndn::Name routerName("/ndn/site/router");
  ndn::Name adjacencyName("/ndn/site/adjacency");
  auto testTimePoint = ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196014943));
  uint32_t seqNo = 12;

  // An AdjLsa initialized with ACTIVE adjacencies should copy the adjacencies
  AdjacencyList activeAdjacencies;
  Adjacent activeAdjacency(adjacencyName);
  activeAdjacency.setStatus(Adjacent::STATUS_ACTIVE);
  activeAdjacencies.insert(activeAdjacency);

  AdjLsa alsa1(routerName, seqNo, testTimePoint,
               activeAdjacencies.size(), activeAdjacencies);
  BOOST_CHECK_EQUAL(alsa1.getAdl().size(), 1);
  BOOST_CHECK_EQUAL(alsa1.getType(), Lsa::Type::ADJACENCY);
  BOOST_CHECK_EQUAL(alsa1.getSeqNo(), seqNo);
  BOOST_CHECK_EQUAL(alsa1.getExpirationTimePoint(), testTimePoint);
  BOOST_CHECK_EQUAL(alsa1.getNoLink(), 1);
  BOOST_CHECK(alsa1.getAdl().isNeighbor(activeAdjacency.getName()));

  // An AdjLsa initialized with INACTIVE adjacencies should not copy the adjacencies
  AdjacencyList inactiveAdjacencies;
  Adjacent inactiveAdjacency(adjacencyName);
  inactiveAdjacency.setStatus(Adjacent::STATUS_INACTIVE);
  inactiveAdjacencies.insert(inactiveAdjacency);

  AdjLsa alsa2(routerName, seqNo, testTimePoint,
               inactiveAdjacencies.size(), inactiveAdjacencies);
  BOOST_CHECK_EQUAL(alsa2.getAdl().size(), 0);

  // Thus, the two LSAs should not have equal content
  BOOST_CHECK_EQUAL(alsa1.isEqualContent(alsa2), false);

  // Create a duplicate of alsa1 which should have equal content
  AdjLsa alsa3(routerName, seqNo, testTimePoint,
               activeAdjacencies.size(), activeAdjacencies);
  BOOST_CHECK(alsa1.isEqualContent(alsa3));

  auto wire = alsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(ADJ_LSA1, ADJ_LSA1 + sizeof(ADJ_LSA1),
                                wire.begin(), wire.end());

  Adjacent activeAdjacency2("/ndn/edu/adjacency");
  activeAdjacency2.setStatus(Adjacent::STATUS_ACTIVE);
  alsa1.addAdjacent(activeAdjacency2);
  wire = alsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(ADJ_LSA_EXTRA_NEIGHBOR,
                                ADJ_LSA_EXTRA_NEIGHBOR + sizeof(ADJ_LSA_EXTRA_NEIGHBOR),
                                wire.begin(), wire.end());

  alsa1.setSeqNo(14);
  wire = alsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(ADJ_LSA_DIFF_SEQ, ADJ_LSA_DIFF_SEQ + sizeof(ADJ_LSA_DIFF_SEQ),
                                wire.begin(), wire.end());

  testTimePoint =
    ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196024993));
  alsa1.setExpirationTimePoint(testTimePoint);
  wire = alsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(ADJ_LSA_DIFF_TS, ADJ_LSA_DIFF_TS + sizeof(ADJ_LSA_DIFF_TS),
                                wire.begin(), wire.end());
}

const uint8_t COORDINATE_LSA1[] = {
  0x85, 0x43, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0C, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x87, 0x08, 0x40, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x88, 0x08, 0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88,
  0x08, 0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t COORDINATE_LSA_DIFF_ANGLE[] = {
  0x85, 0x39, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0C, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x87, 0x08, 0x40, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x88, 0x08, 0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t COORDINATE_LSA_DIFF_RADIUS[] = {
  0x85, 0x39, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0C, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x87, 0x08, 0x40, 0x02, 0x66, 0x66,
  0x66, 0x66, 0x66, 0x66, 0x88, 0x08, 0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t COORDINATE_LSA_DIFF_SEQ[] = {
  0x85, 0x39, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0E, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, 0x87, 0x08, 0x40, 0x02, 0x66, 0x66,
  0x66, 0x66, 0x66, 0x66, 0x88, 0x08, 0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t COORDINATE_LSA_DIFF_TS[] = {
  0x85, 0x39, 0x80, 0x23, 0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31,
  0x82, 0x01, 0x0E, 0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36,
  0x20, 0x30, 0x34, 0x3A, 0x31, 0x33, 0x3A, 0x34, 0x34, 0x87, 0x08, 0x40, 0x02, 0x66, 0x66,
  0x66, 0x66, 0x66, 0x66, 0x88, 0x08, 0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

BOOST_AUTO_TEST_CASE(CoordinateLsaBasic)
{
  auto testTimePoint = ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196014943));
  std::vector<double> angles1{30.0}, angles2{30.0};
  angles1.push_back(30.0);
  angles2.push_back(30.0);
  CoordinateLsa clsa1("router1", 12, testTimePoint, 2.5, angles1);
  CoordinateLsa clsa2("router1", 12, testTimePoint, 2.5, angles2);

  BOOST_CHECK_CLOSE(clsa1.getCorRadius(), 2.5, 0.0001);
  BOOST_CHECK(clsa1.getCorTheta() == angles1);

  BOOST_CHECK(clsa1.isEqualContent(clsa2));

  BOOST_CHECK_EQUAL(clsa1.wireEncode(), clsa2.wireEncode());

  auto wire = clsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(COORDINATE_LSA1, COORDINATE_LSA1 + sizeof(COORDINATE_LSA1),
                                wire.begin(), wire.end());

  std::vector<double> angles3{40.0};
  clsa1.setCorTheta(angles3);
  wire = clsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(COORDINATE_LSA_DIFF_ANGLE,
                                COORDINATE_LSA_DIFF_ANGLE + sizeof(COORDINATE_LSA_DIFF_ANGLE),
                                wire.begin(), wire.end());

  clsa1.setCorRadius(2.3);
  wire = clsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(COORDINATE_LSA_DIFF_RADIUS,
                                COORDINATE_LSA_DIFF_RADIUS + sizeof(COORDINATE_LSA_DIFF_RADIUS),
                                wire.begin(), wire.end());

  clsa1.setSeqNo(14);
  wire = clsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(COORDINATE_LSA_DIFF_SEQ,
                                COORDINATE_LSA_DIFF_SEQ + sizeof(COORDINATE_LSA_DIFF_SEQ),
                                wire.begin(), wire.end());

  testTimePoint =
    ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196024993));
  clsa1.setExpirationTimePoint(testTimePoint);
  wire = clsa1.wireEncode();
  BOOST_CHECK_EQUAL_COLLECTIONS(COORDINATE_LSA_DIFF_TS,
                                COORDINATE_LSA_DIFF_TS + sizeof(COORDINATE_LSA_DIFF_TS),
                                wire.begin(), wire.end());
}

BOOST_AUTO_TEST_CASE(IncrementAdjacentNumber)
{
  Adjacent adj1("adjacent1");
  Adjacent adj2("adjacent2");

  adj1.setStatus(Adjacent::STATUS_ACTIVE);
  adj2.setStatus(Adjacent::STATUS_ACTIVE);

  AdjacencyList adjList;
  adjList.insert(adj1);
  adjList.insert(adj2);

  auto testTimePoint = ndn::time::system_clock::now() + ndn::time::seconds(3600);

  AdjLsa lsa("router1", 12, testTimePoint, adjList.size(), adjList);

  std::ostringstream os;
  os << lsa;

  std::string EXPECTED_OUTPUT =
    "    ADJACENCY LSA:\n"
    "      Origin Router      : /router1\n"
    "      Sequence Number    : 12\n"
    "      Expires in         : 3599999 milliseconds\n"
    "      Adjacent(s):\n"
    "        Adjacent 0: (name=/adjacent1, uri=://, cost=10)\n"
    "        Adjacent 1: (name=/adjacent2, uri=://, cost=10)\n";

  BOOST_CHECK_EQUAL(os.str(), EXPECTED_OUTPUT);
}

BOOST_AUTO_TEST_CASE(TestInitializeFromContent)
{
  //Adj LSA
  Adjacent adj1("adjacent1");
  Adjacent adj2("adjacent2");

  adj1.setStatus(Adjacent::STATUS_ACTIVE);
  adj2.setStatus(Adjacent::STATUS_ACTIVE);

  //If we don't do this the test will fail
  //Adjacent has default cost of 10 but no default
  //connecting face URI, so initializeFromContent fails
  adj1.setFaceUri(ndn::FaceUri("udp://10.0.0.1"));
  adj2.setFaceUri(ndn::FaceUri("udp://10.0.0.2"));

  AdjacencyList adjList;
  adjList.insert(adj1);
  adjList.insert(adj2);

  auto testTimePoint = ndn::time::system_clock::now();

  AdjLsa adjlsa1("router1", 1, testTimePoint, adjList.size(), adjList);
  AdjLsa adjlsa2(adjlsa1.wireEncode());
  BOOST_CHECK(adjlsa1.isEqualContent(adjlsa2));

  //Name LSA
  ndn::Name s1{"name1"};
  ndn::Name s2{"name2"};
  NamePrefixList npl1{s1, s2};

  NameLsa nlsa1("router1", 1, testTimePoint, npl1);
  NameLsa nlsa2(nlsa1.wireEncode());
  BOOST_CHECK_EQUAL(nlsa1.wireEncode(), nlsa2.wireEncode());

  //Coordinate LSA
  std::vector<double> angles = {30, 40.0};
  CoordinateLsa clsa1("router1", 12, testTimePoint, 2.5, angles);
  CoordinateLsa clsa2(clsa1.wireEncode());
  BOOST_CHECK_EQUAL(clsa1.wireEncode(), clsa2.wireEncode());
}

BOOST_AUTO_TEST_CASE(OperatorEquals)
{
  NameLsa lsa1;
  NameLsa lsa2;
  ndn::Name name1("/ndn/test/name1");
  ndn::Name name2("/ndn/test/name2");
  ndn::Name name3("/ndn/some/other/name1");

  lsa1.addName(name1);
  lsa1.addName(name2);
  lsa1.addName(name3);

  lsa2.addName(name1);
  lsa2.addName(name2);
  lsa2.addName(name3);

  BOOST_CHECK(lsa1.isEqualContent(lsa2));
}

BOOST_AUTO_TEST_CASE(NameLsaUpdate)
{
  NameLsa knownNameLsa;
  knownNameLsa.m_originRouter = ndn::Name("/yoursunny/_/%C1.Router/dal");
  knownNameLsa.m_seqNo = 2683;
  knownNameLsa.setExpirationTimePoint(ndn::time::system_clock::now() + 3561_ms);
  knownNameLsa.addName("/yoursunny/_/dal");
  knownNameLsa.addName("/ndn");

  std::shared_ptr<Lsa> rcvdLsa = std::make_shared<NameLsa>();

  rcvdLsa->m_originRouter = ndn::Name("/yoursunny/_/%C1.Router/dal");
  rcvdLsa->m_seqNo = 2684;
  rcvdLsa->setExpirationTimePoint(ndn::time::system_clock::now() + 3600_ms);
  auto nlsa = std::static_pointer_cast<NameLsa>(rcvdLsa);
  nlsa->addName("/ndn");
  nlsa->addName("/yoursunny/_/dal");
  ndn::Name addedName1("/yoursunny/video/ndn-dpdk_acmicn20_20200917");
  ndn::Name addedName2("/yoursunny/pushups");
  nlsa->addName(addedName1);
  nlsa->addName(addedName2);

  bool updated;
  std::list<ndn::Name> namesToAdd, namesToRemove, mcNamesToAdd, mcNamesToRemove;
  std::tie(updated, namesToAdd, namesToRemove, mcNamesToAdd, mcNamesToRemove) = knownNameLsa.update(rcvdLsa);

  BOOST_CHECK_EQUAL(namesToRemove.size(), 0);
  BOOST_CHECK_EQUAL(namesToAdd.size(), 2);
  auto it = std::find(namesToAdd.begin(), namesToAdd.end(), addedName1);
  BOOST_CHECK(it != namesToAdd.end());
  it = std::find(namesToAdd.begin(), namesToAdd.end(), addedName2);
  BOOST_CHECK(it != namesToAdd.end());
}

BOOST_AUTO_TEST_SUITE_END()

} // namespace test
} // namespace nlsr
